---
layout:     post
title:      "python解决八皇后问题"
subtitle:   ""
date:       2016-10-25
author:     "MaggicQ"
tags:
    - python
    - 回溯
    - 迭代
    - 八皇后问题
---




## 迭代器

**_迭代_**  就是重复做一些事很多次，就像循环一样。在python中我们不仅能对字典和序列进行迭代，还能对我们自定义的对象进行迭代，只要这个对象实现了 __ iter __ 方法 。

这个方法会返回一个迭代器，迭代器是具有next方法的对象，在调用next方法时，迭代器会返回它的下一个值。

使用迭代器而不是直接使用列表是因为如果需要的数据很多，使用列表将会占用太多内存，而迭代器则没有这种问题。

下面是一个迭代器的例子

```python
# coding=utf-8
class Fibs:
    def  __init__(self):
        self.a=0
        self.b=1

    def next(self):
        self.a,self.b=self.b,self.a+self.b
        return self.a
    #别忘了这个函数是迭代器的关键
    def __iter__(self):
        return self
```

在python的3.0版本或者以上，需要将next方法的名字改成__ next __  ，否则会报错。



## 生成器与回溯

生成器可以堪称是一种用普通的函数语法定义的迭代器，只是普通的函数使用`return`返回值，而生成器使用`yeild`返回值。当它被调用时，在函数体内的代码不会被执行，而会返回一个迭代器，每次用next()方法请求一个值，就会执行生成器中的代码，知道遇上yield语句。

下面是一个使用生成器的例子（这里使用的）：

```python
>>> a=0
>>> b=1
>>> def f(num):
...     global a,b   #奇怪的是 ， 如果你没加这一句，解释器会报错 。
...     for i in range(num):
...             a,b=b,a+b
...             yield a
...
>>> t=f(10)			#这里会返回一个生成器 把它赋给t
>>> t.next()
1
>>> t.next()
1
>>> t.next()
2
>>> t.next()
3
>>> a
3
>>> b
5
>>> t.next()
5
>>> t.next()
8
>>> a   # a，b的值也发生了变化，可见next调用一次，代码才执行一次。
8
>>> b
13
```

而回溯(backtracking）是 **暴力搜寻法** 中的一种,可以采用 **试错** 的思想，它尝试分步的f方法去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。

利用生成器或者迭代器可以很好的实现回溯。



## 八皇后问题

### 问题描述

八皇后问题最早是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出。它是一个以国际象棋为背景的问题：如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能	处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当 n = 1 或 n ≥ 4 时问题有解。

八皇后问题总共有92种解法，下图是其中的一种：

 ![八皇后问题](/img/queen.png)

### 问题解决

为了方便地判断皇后之间的位置是否有冲突，我们先定义一个冲突函数：

```python
#coding=utf-8
def conflict(state,nextX):
    '''
    对所使用到的变量的解释：
    state[i] : 表示第i个皇后的水平位置
    i       ：也是它本身的垂直位置
    nextX  nextY ：表示下一个皇后的水平位置和垂直位置

    '''
    nextY=len(state)#皇后的个数
    for i in range(nextY):
        '''
        若abs(state[i]-nextx)为0，说明水平位置相同
        若该式等于nextY-i 说明两个比较的皇后之间的
        水平距离和垂直距离相等，这两种情况都会产生冲突
        '''
        if abs(state[i]-nextX) in (0,nextY-i):
            return True
    return False
```

定义好冲突函数之后，我们就可以开始放置皇后了，在放置皇后的时候，我们可以回溯的方法，也就是逐个位置进行尝试，若是遇到冲突就尝试下一种情况，遍历所有可能，找出不存在冲突的布局就行了。

```python
def queens(num=8,state=()):
    for pos in range(num):
        if not conflict(state,pos):
            if len(state)==num-1:
                yield (pos,)
            else:
                for result in queens(num,state+(pos,)):
                    yield (pos,)+result
```

这里采用了递归（调用本身）的方法，这样利用简洁的代码便可穷举所有可能。如果不清楚这个函数运作的过程，可以加上print函数，然后利用简单的例子比如运行queens(4)来查看过程：

```python
def queens(num=8,state=()):
    for pos in range(num):
        if not conflict(state,pos):
            if len(state)==num-1:
                print "queen(%s,%s) 返回的结果是 %s"%(num,str(state),pos)
                yield (pos,)
            else:
                print "queens(%s,%s)递归调用了queens(%s,%s)"%(num,state,num,str(state+(pos,)))
                for result in queens(num,state+(pos,)):
                    # print "%s in queens(%s,%s)"%(result,num,str(state+(pos,)))
                    # print "(pos,)+result  is ",(pos,)+result
                    print "queen(%s,%s) 返回的结果是 %s"%(num,str(state),(pos,)+result)
                    yield (pos,)+result

print(list(queens(4)))
```

程序输出的结果是：

```sh
luo@luo-ThinkPad-Edge-E431:~/python_learning$ python bahuanghou.py
queens(4,())递归调用了queens(4,(0,))
queens(4,(0,))递归调用了queens(4,(0, 2))
queens(4,(0,))递归调用了queens(4,(0, 3))
queens(4,(0, 3))递归调用了queens(4,(0, 3, 1))#层层递归 pos=0时没找到答案
queens(4,())递归调用了queens(4,(1,))
queens(4,(1,))递归调用了queens(4,(1, 3))
queens(4,(1, 3))递归调用了queens(4,(1, 3, 0))
queen(4,(1, 3, 0)) 返回的结果是 2 #找到了一个可行的方案
queen(4,(1, 3)) 返回的结果是 (0, 2) #层层返回
queen(4,(1,)) 返回的结果是 (3, 0, 2)
queen(4,()) 返回的结果是 (1, 3, 0, 2)  #回到第一层函数  得到我们要的结果
queens(4,())递归调用了queens(4,(2,))  #下面同理
queens(4,(2,))递归调用了queens(4,(2, 0))
queens(4,(2, 0))递归调用了queens(4,(2, 0, 3))
queen(4,(2, 0, 3)) 返回的结果是 1
queen(4,(2, 0)) 返回的结果是 (3, 1)
queen(4,(2,)) 返回的结果是 (0, 3, 1)
queen(4,()) 返回的结果是 (2, 0, 3, 1)
queens(4,())递归调用了queens(4,(3,))
queens(4,(3,))递归调用了queens(4,(3, 0))
queens(4,(3, 0))递归调用了queens(4,(3, 0, 2))
queens(4,(3,))递归调用了queens(4,(3, 1))
[(1, 3, 0, 2), (2, 0, 3, 1)]
```

认真查看上面的输出结果，可能就会对这个函数的工作过程有较深的了解了。接下来是一些更加完善的输出。因为八皇后问题有九十二种解法，所以我们可以考虑输出其中一种即可：

```python
def prettyprint(solution):
    def line(pos,length=len(solution)):
        return '. '*(pos)+'X '+'. '*(length-pos-1)
    for pos in solution:
        print line(pos)
import random
prettyprint(random.choice(list(queens(8))))
```

这样的输出可能是：

```sh
luo@luo-ThinkPad-Edge-E431:~/python_learning$ python bahuanghou.py
. . . . . X . .
. . X . . . . .
X . . . . . . .
. . . . . . . X
. . . X . . . .
. X . . . . . .
. . . . . . X .
. . . . X . . .
```

这样看起来就直观多了。





## 总结

八皇后是一个经典的问题，解决的方法有很多种，这里只是给出了用回溯解决的实现。想要深入了解的应该参考其他资料。解决这种问题可以锻炼我们的思维，同时加深对算法以及编程语言的了解，对我们是很有好处的！



参考资料： python基础教程（文中的代码实现也是摘自此书）
