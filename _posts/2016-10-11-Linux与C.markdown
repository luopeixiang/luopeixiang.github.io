---
layout:     post
title:      "Linux与C"
subtitle:   ""
date:       2016-10-11
author:     "MaggicQ"
tags:
    - Linux
    - C语言
---

[TOC]

# 开发工具

## gcc

**gcc**是 GNU Compiler Collection的缩写 ，翻译过来就是GNU编译器套装，它是GNU项目的关键部分，也是GNU工具链的主要组成部分之一 。

> GNU 计划是一个自由软件集体协作项目 ，它的目标是创建一套完全自由的操作系统 ，在1983年由MIT的_**Richard Matthew Stallman**_发起 。GNU软件可以自由地“使用、复制、修改和发布” ，在开源运动的推动下，GNU产生了许多著名的软件。

### 工作过程

gcc在执行编译工作时，需要以下四步：

1. 预处理 ，生成  **.i**  文件 。

2. 将预处理之后的文件转换成汇编语言 ， 生成  **.s**   文件 。

3. 由汇编变为目标代码（机器代码），生成  **.o**  文件。

4. 连接目标代码 ，生成可执行程序 。

   ​

### 编译运行C程序

编写一个简单的hello.c文件：

```C
#include<stdio.h>
int main()
{
	printf("hell world!");
	return 0;  
}
```

然后在命令行执行：

```sh
gcc hello.c
```

这条命令会产`a.out`的可执行文件，只要在当前目录下运行`./a.out`就能看到运行结果了。如果不想用默认的`./a.out`可以使用`-o`选项指定另一个名字，比如：

```sh
gcc -o hello hello.c
```

然后在运行`hello`命令就行了 。

一些常用的gcc命令行选项有：

* -o	:    想指定输出的文件
* -c     :    只激活预处理 ，编译， 和汇编，也就是只把程序做成 **obj** 文件，而不是可执行文件。
* -S    :    只激活预处理和编译，就是把文件编译成汇编代码。
* -E   ：  只激活预处理，这个不生成文件，结果会被送到标准输出 ，你可以将它重定向到文件查看 。
* -O   ：  选择编译优化级别，级别可设定为为1 - 3 , 级别越大优化效果越好，但同时也需要更多的时间 。

### 编译运行多个源文件

如果有多个源文件，基本上有两种编译方法 ，现在我们假设有两个源文件为test.c和testfun.c需要编译：

1. 多个文件一起编译 

```sh
gcc testfun.c test.c -o test
```

作用：将testfun.c和test.c分别编译后链接成test可执行文件。

2. 分别编译各个源文件，之后对编译后输出的目标文件链接。 

用法： 

```sh
gcc -c testfun.c
gcc -c test.c
gcc -o testfun.o test.o -o tes
```

以上每条语句对应的是：

将testfun.c编译成testfun.o 
将test.c编译成test.o 
将testfun.o和test.o链接成test

以上两种方法相比较各有优缺点，第一种方法比较简洁，不过当你对文件做了改动之后，编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译。



### 头文件和目录

**C**的头文件适用于保存类型和函数声明的附加文件 ， 在上述`hello.c`文件中的`stdio.h`文件就是一个典型的头文件 ， Unix默认的头文件目录是`usr/include` ,

编译器会去那里寻找头文件 ， 如果你想要让编译器去别的地方寻找，可以在编译时加上`-I`选项 。 比如：

```sh
gcc -c -I /usr/junk/include badinclude.c
```

同时，头文件也可以用双引号括起来，这样意味着这个头文件不再系统include目录下 ，编译器一般会在当前目录寻找它 。



### C预处理器

其实在实际编译过程中，去寻找include文件的是C预处理器 （C Preprocessor  简称cpp）。它是编译器在解析程序之前先在源码上运行的东西，预处理器会将源码重写为一种编译器能理解的形式。一般来说，C预处理器并不懂C的任何语法，它只看宏和指令。



## 连接库

所谓C语言库，就是一些已经编译好的，通用的，可让你添加到自己程序的函数。例如，很多可执行程序都会用到数学库。

也可以这么理解库是预编译的目标文件(object files)的集合，它们可被链接进程序。静态库以后缀为‘.a’的特殊的*存档文件(archive file)*存储。

标准系统库可在目录 **/usr/lib** 与 **/lib** 中找到。比如，在类 Unix 系统中 C 语言的数学库一般存储为文件 **/usr/lib/libm.a**。该库中函数的原型声明在头文件 **/usr/include/math.h** 中。



库主要是连接的时候（也就是连接器从文件对象中产生可执行程序时）发挥作用。

与连接库有关的编译器命令选项是`-l`和`-L`选项，这里不细说，需要了解可以查看文档。



## 共享库

### 为什么需要共享库？

当程序连接的是静态库时，连接器会将库文件中的机器码复制到你的程序中，这样以后运行你的程序时，没有这些库也能够运行起来。

但是这也引出了一些问题，比如如果库很大，那就意味着复制静态库很浪费硬盘和内存空间，而且若是静态库有问题存在，那么以前和它连接过的程序都需要重新编译。

所以这就引入了共享库(也可以叫做动态库) ，引用动态库的程序只会在需要时才将库加载到内存中。而且多个进程可以共享内存中的一个共享库，修改共享库的代码不需要重新运行那些引用它的程序。

但使用共享库比起静态库管理更加困难，连接也较复杂。



### 进一步了解共享库

共享库和静态库通常放在同一个地方。linux两大标准库目录是`/lib` 和 `/usr/lib`其中`/lib`不包含静态库。 共享库的名字后缀一般是`.so`(意即共享对象) ， 想要查看一个程序用到了哪些共享库，可以运行`ldd`命令：

```sh
luo@luo-ThinkPad-Edge-E431:~$ ldd /usr/bin/python
	linux-vdso.so.1 =>  (0x00007fff1315d000)
	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f2bdd198000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2bdcdcf000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f2bdcbca000)
	libutil.so.1 => /lib/x86_64-linux-gnu/libutil.so.1 (0x00007f2bdc9c7000)
	libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f2bdc7ad000)
	libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f2bdc4a3000)
	/lib64/ld-linux-x86-64.so.2 (0x000055584d3b0000)
```

上面列出了python所使用的共享库的名称和位置。



### 程序如何找到共享库

`ld.so`（动态连接器）可以为程序在运行时找到并加载共享库。一般来说，如果可执行程序有预先配置好的运行时搜索路径（可以在编译时通过`-rpath`选项设置），则动态连接器会首先寻找那里，接着动态连接器会参考系统缓存`/etc/ld.so.cache`看这个库是否在常规的位置，这是从缓存配置文件`/etc/ld.so.conf`中的目录列表中获取的库文件名字的快速缓存。



## 了解的更多

----

### make

当一个程序需要很多个源码文件时，手工编译不仅麻烦而且容易出现错误，make就是为了解决这种问题而出现的编译管理工具。

make会根据一些规则，例如怎么样将.c文件变成.o文件，来构建目标，一般来说这些规则写在一个叫makefile的文件里。

make是一个很大的系统，这里不详细展开。想要学习make ，可以参考以下这些资料：

[GNU make 手册](https://www.gnu.org/software/make/manual/make.html#Reading)

[阮一峰的网络日志 make命令教程](http://www.ruanyifeng.com/blog/2015/02/make.html)





### 调试利器gdb

很多时候我们编写的程序是无法做到一次性通过编译的，如果程序很复杂，那么就需要用到调试的工具了。`gdb`就是一个很好的调试的工具。下面是对名为hello的可执行程序运行gdb ：

```sh
gdb hello
```

这样就会进入gdb命令提示符。你可在这里通过gdb的各种命令运行调试你的程序。

关于gdb更多内容可参考：

[GNU gdb文档](https://www.gnu.org/software/gdb/documentation/)

[Ubuntu中文 用gdb调试程序](http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F)





## 从C代码中编译出软件

大部分非专利的第三方Unix软件都是以源代码的形式放出的，让人们能自行构建并安装。从C代码安装一个软件，通常包括：

- 将源代码的归档解包，可以先用命令`tar -ztvf`检查一下包的内容，再用`tar -xvf`解开。
- 对包进行设置，一般来说通过GNU autoconf你可以自动产生Makefile ，只要在终端下运行`./configure`命令就行了。
- 运行make来构建程序。
- 运行make install或者发行版特定的安装命令来安装该包。

一般来说，安装软件时软件源码包里面都会带有说明书，说明一些注意的事项。那也是成功安装的关键。



## 总结

上面就是关于Linux与C的一些内容，在Linux 下进行C编程是很方便的。这篇博客主要的重点在连接库和共享库，前面的一些关于如何编译C的总结应该算是常识，后面介绍的几个方面包括 make ，gdb 等等都是很大的领域，但也是进阶学习需要接触到的东西，目前我还没有深入了解（太菜了），无论如何，希望这篇总结能帮助到一些刚接触linux下C编程的同学=0= 。
